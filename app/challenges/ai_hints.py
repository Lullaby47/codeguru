"""
AI Hint generation for wrong submissions.

Generates a short, actionable, contextual tip using OpenAI.
Falls back to smart rule-based tips when OpenAI is unavailable.
Caches hints in submission_insights.ai_hint (one call per submission).
"""
import traceback

try:
    import openai
    _OPENAI_OK = True
except ImportError:
    _OPENAI_OK = False

from app.core.config import OPENAI_API_KEY

# ---------------------------------------------------------------------------
# PUBLIC API
# ---------------------------------------------------------------------------


def generate_ai_hint(
    challenge_title: str,
    challenge_prompt: str,
    expected_output: str,
    user_code: str,
    actual_output: str,
    error_text: str | None = None,
) -> tuple[str, bool]:
    """
    Generate a contextual hint for a wrong submission.

    Returns (hint_text, is_ai).
      is_ai=True  → generated by OpenAI
      is_ai=False → rule-based fallback
    """
    # ── Try OpenAI first ─────────────────────────────────────────────────
    if _OPENAI_OK and OPENAI_API_KEY and OPENAI_API_KEY.strip():
        try:
            hint = _call_openai(
                challenge_title, challenge_prompt,
                expected_output, user_code,
                actual_output, error_text,
            )
            if hint and hint.strip():
                return hint.strip(), True
        except Exception as exc:
            print(f"[AI HINT] OpenAI call failed: {exc}", flush=True)
            # fall through to rule-based

    # ── Rule-based fallback ──────────────────────────────────────────────
    return _fallback_hint(actual_output, error_text, expected_output), False


# ---------------------------------------------------------------------------
# OpenAI call (short, focused prompt — NOT the progressive mentor system)
# ---------------------------------------------------------------------------

_SYSTEM = (
    "You are a concise coding mentor. "
    "Given a student's wrong submission, produce ONE short hint (1-2 sentences). "
    "Rules:\n"
    "- NEVER give the full solution or corrected code.\n"
    "- If there is a syntax/runtime error, mention the error type and the likely line.\n"
    "- If the output is wrong, point out the most likely cause (wrong variable, missing newline, etc.).\n"
    "- Be actionable: tell the student what to CHECK or CHANGE, not what the answer is.\n"
    "- Plain text only. No markdown, no code blocks, no emojis.\n"
    "- Maximum 2 sentences."
)


def _call_openai(
    title: str, prompt: str, expected: str,
    code: str, output: str, error: str | None,
) -> str | None:
    client = openai.OpenAI(api_key=OPENAI_API_KEY, timeout=10)

    # Build a compact user message
    parts = [f"Challenge: {title}"]
    if prompt:
        parts.append(f"Description: {prompt[:500]}")
    if expected:
        parts.append(f"Expected output:\n{expected[:300]}")
    parts.append(f"Student code:\n{code[:800]}")
    if error:
        parts.append(f"Error/traceback:\n{error[:400]}")
    elif output:
        parts.append(f"Actual output:\n{output[:300]}")

    user_msg = "\n\n".join(parts)

    resp = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": _SYSTEM},
            {"role": "user", "content": user_msg},
        ],
        max_tokens=120,
        temperature=0.4,
    )
    return resp.choices[0].message.content


# ---------------------------------------------------------------------------
# Smart fallback (no AI)
# ---------------------------------------------------------------------------

_SYNTAX_KEYWORDS = [
    "SyntaxError", "IndentationError", "TabError",
    "NameError", "TypeError", "ValueError",
    "AttributeError", "IndexError", "KeyError",
    "ZeroDivisionError", "FileNotFoundError",
    "Traceback (most recent call last)",
]


def _fallback_hint(output: str, error: str | None, expected: str) -> str:
    """Return a smart rule-based tip based on the error signature."""
    text = (error or output or "").strip()

    if not text:
        return "Your code produced no output. Make sure you are printing a result."

    # Syntax / runtime errors
    if "SyntaxError" in text:
        return "You have a syntax error — check for missing quotes, parentheses, or colons on the indicated line."
    if "IndentationError" in text or "TabError" in text:
        return "Your indentation is inconsistent — make sure every block uses the same number of spaces."
    if "NameError" in text:
        return "You're using a variable or function that hasn't been defined. Check your spelling and make sure it's declared before use."
    if "TypeError" in text:
        return "You're mixing incompatible types (e.g. string + int). Check the types of your variables."
    if "IndexError" in text:
        return "You're accessing a list index that doesn't exist. Check your loop bounds or list length."
    if "KeyError" in text:
        return "You're accessing a dictionary key that doesn't exist. Verify the key name."
    if "Traceback" in text:
        return "Your code raised a runtime error. Read the last line of the traceback to identify the problem."

    # Output mismatch
    if expected and text:
        if text.lower().strip() == expected.lower().strip() and text.strip() != expected.strip():
            return "Your output is almost correct but has a capitalization or whitespace difference. Compare character by character."
        return "Your output doesn't match the expected result. Compare spacing, capitalization, and newlines carefully."

    return "Double-check your logic and compare your output to the expected output."
