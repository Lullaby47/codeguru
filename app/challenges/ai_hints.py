"""
AI Hint generation for wrong submissions.

Generates a short, actionable, contextual tip using OpenAI.
Falls back to smart rule-based tips when OpenAI is unavailable.
Caches hints in submission_insights.ai_hint (one call per submission).
"""
from app.ai.openai_client import get_client, key_present, set_last_error

# ---------------------------------------------------------------------------
# PUBLIC API
# ---------------------------------------------------------------------------


def generate_ai_hint(
    challenge_title: str,
    challenge_prompt: str,
    expected_output: str,
    user_code: str,
    actual_output: str,
    error_text: str | None = None,
) -> tuple[str, bool]:
    """
    Generate a contextual hint for a wrong submission.

    Returns (hint_text, is_ai).
      is_ai=True  -> generated by OpenAI
      is_ai=False -> rule-based fallback
    """
    # ── Try OpenAI first ─────────────────────────────────────────────────
    client = get_client()
    if client is not None:
        try:
            hint = _call_openai(
                client,
                challenge_title, challenge_prompt,
                expected_output, user_code,
                actual_output, error_text,
            )
            if hint and hint.strip():
                return hint.strip(), True
        except Exception as exc:
            _handle_openai_error(exc)
            # fall through to rule-based

    # ── Rule-based fallback ──────────────────────────────────────────────
    return _fallback_hint(actual_output, error_text, expected_output), False


# ---------------------------------------------------------------------------
# OpenAI call (short, focused prompt — NOT the progressive mentor system)
# ---------------------------------------------------------------------------

_SYSTEM = (
    "You are a concise coding mentor. "
    "Given a student's wrong submission, produce ONE short hint (1-2 sentences). "
    "Rules:\n"
    "- NEVER give the full solution or corrected code.\n"
    "- If there is a syntax/runtime error, mention the error type and the likely line.\n"
    "- If the output is wrong, point out the most likely cause (wrong variable, missing newline, etc.).\n"
    "- Be actionable: tell the student what to CHECK or CHANGE, not what the answer is.\n"
    "- Plain text only. No markdown, no code blocks, no emojis.\n"
    "- Maximum 2 sentences."
)


def _call_openai(client, title, prompt, expected, code, output, error):
    parts = [f"Challenge: {title}"]
    if prompt:
        parts.append(f"Description: {prompt[:500]}")
    if expected:
        parts.append(f"Expected output:\n{expected[:300]}")
    parts.append(f"Student code:\n{code[:800]}")
    if error:
        parts.append(f"Error/traceback:\n{error[:400]}")
    elif output:
        parts.append(f"Actual output:\n{output[:300]}")

    user_msg = "\n\n".join(parts)

    resp = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": _SYSTEM},
            {"role": "user", "content": user_msg},
        ],
        max_tokens=120,
        temperature=0.4,
    )
    return resp.choices[0].message.content


def _handle_openai_error(exc):
    """Log OpenAI errors cleanly — no noisy stack traces."""
    try:
        import openai as _openai
        if isinstance(exc, _openai.AuthenticationError):
            msg = "[AI] auth error (401) - check OPENAI_API_KEY"
            print(msg, flush=True)
            set_last_error(msg)
            return
    except ImportError:
        pass
    msg = f"[AI HINT] OpenAI call failed: {exc}"
    print(msg, flush=True)
    set_last_error(msg)


# ---------------------------------------------------------------------------
# Smart fallback (no AI)
# ---------------------------------------------------------------------------

# Keywords that indicate a syntax/runtime error — checked against BOTH
# the error_text and actual_output fields.
_ERROR_SIGNATURES = [
    "SyntaxError", "invalid syntax", "unexpected EOF",
    "IndentationError", "TabError",
    "NameError", "TypeError", "ValueError",
    "AttributeError", "IndexError", "KeyError",
    "ZeroDivisionError", "FileNotFoundError",
    "Traceback (most recent call last)",
    "EOFError", "RecursionError",
]


def _fallback_hint(actual_output: str, error_text: str | None, expected: str) -> str:
    """Return a smart rule-based tip based on the error signature."""
    # Combine both sources so we never miss an error keyword
    combined = ((error_text or "") + " " + (actual_output or "")).strip()

    if not combined:
        return "Your code produced no output. Make sure you are printing a result."

    # ── Syntax / compile errors (highest priority) ───────────────────────
    if "SyntaxError" in combined or "invalid syntax" in combined or "unexpected EOF" in combined:
        return "Your code has a syntax error — check for missing quotes, parentheses, or commas on the indicated line."
    if "IndentationError" in combined or "TabError" in combined or "unexpected indent" in combined:
        return "Your indentation is inconsistent — make sure every block uses the same number of spaces."

    # ── Runtime errors ───────────────────────────────────────────────────
    # Check both class names (e.g. "NameError") and message patterns
    # (e.g. "name 'x' is not defined") because str(exception) omits class.
    if "NameError" in combined or "is not defined" in combined:
        return "You're using a variable or function that hasn't been defined. Check your spelling and make sure it's declared before use."
    if "TypeError" in combined or "unsupported operand" in combined or "can only concatenate" in combined:
        return "You're mixing incompatible types (e.g. string + int). Check the types of your variables."
    if "IndexError" in combined or "list index out of range" in combined:
        return "You're accessing a list index that doesn't exist. Check your loop bounds or list length."
    if "KeyError" in combined:
        return "You're accessing a dictionary key that doesn't exist. Verify the key name."
    if "ZeroDivisionError" in combined or "division by zero" in combined:
        return "You're dividing by zero. Check your divisor variable before the division."
    if "Traceback" in combined:
        return "Your code raised a runtime error. Read the last line of the traceback to identify the problem."

    # ── No output at all ─────────────────────────────────────────────────
    actual = (actual_output or "").strip()
    if not actual:
        return "Your code produced no output. Make sure you are printing a result."

    # ── Output mismatch ──────────────────────────────────────────────────
    if expected and actual:
        if actual.lower().strip() == expected.lower().strip() and actual.strip() != expected.strip():
            return "Your output is almost correct but has a capitalization or whitespace difference. Compare character by character."
        return "Your output doesn't match the expected result. Compare spacing, capitalization, and newlines carefully."

    return "Double-check your logic and compare your output to the expected output."
